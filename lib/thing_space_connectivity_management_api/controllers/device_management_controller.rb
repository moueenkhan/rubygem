# thing_space_connectivity_management_api
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module ThingSpaceConnectivityManagementApi
  # DeviceManagementController
  class DeviceManagementController < BaseController
    def initialize(config, http_call_back: nil)
      super(config, http_call_back: http_call_back)
    end

    # If the devices do not already exist in the account, this API resource adds
    # them before activation.
    # @param [CarrierActivateRequest] body Required parameter: Request for
    # activating a service on devices.
    # @return [DeviceManagementResult] response from the API call
    def activate_service_for_devices(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/activate'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Use this API if you want to manage some device settings before you are
    # ready to activate service for the devices.
    # @param [AddDevicesRequest] body Required parameter: Devices to add.
    # @return [List of AddDevicesResult] response from the API call
    def add_devices(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/add'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      decoded.map { |element| AddDevicesResult.from_hash(element) }
    end

    # Sends a CarrierService callback message for each device in the request
    # when the contact information has been changed, or if there was a problem
    # and the change could not be completed.
    # @param [ContactInfoUpdateRequest] body Required parameter: Request to
    # update contact information for devices.
    # @return [DeviceManagementResult] response from the API call
    def update_devices_contact_information(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/contactinfo'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Sends a CarrierService callback message for each device in the request
    # when the custom fields have been changed, or if there was a problem and
    # the change could not be completed.
    # @param [CustomFieldsUpdateRequest] body Required parameter: Request to
    # update custom field of devices.
    # @return [DeviceManagementResult] response from the API call
    def update_devices_custom_fields(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/customFields'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Deactivating service for a device may result in an early termination fee
    # (ETF) being charged to the account, depending on the terms of the contract
    # with Verizon. If your contract allows ETF waivers and if you want to use
    # one for a particular deactivation, set the etfWaiver value to True.
    # @param [CarrierDeactivateRequest] body Required parameter: Request to
    # deactivate service for one or more devices.
    # @return [DeviceManagementResult] response from the API call
    def deactivate_service_for_devices(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/deactivate'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Use this API to remove unneeded devices from an account.
    # @param [DeleteDevicesRequest] body Required parameter: Devices to
    # delete.
    # @return [List of DeleteDevicesResult] response from the API call
    def delete_deactivated_devices(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/delete'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      decoded.map { |element| DeleteDevicesResult.from_hash(element) }
    end

    # Returns information about a single device or information about all devices
    # that match the given parameters. Returned information includes device
    # provisioning state, service plan, MDN, MIN, and IP address.
    # @param [AccountDeviceListRequest] body Required parameter: Device
    # information query.
    # @return [AccountDeviceListResult] response from the API call
    def list_devices_information(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/list'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      AccountDeviceListResult.from_hash(decoded)
    end

    # Returns a list of all 4G devices with an ICCID (SIM) that was not
    # activated with the expected IMEI (hardware) during a specified time frame.
    # @param [DeviceMismatchListRequest] body Required parameter: Request to
    # list devices with mismatched IMEIs and ICCIDs.
    # @return [DeviceMismatchListResult] response from the API call
    def list_devices_with_imei_iccid_mismatch(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/list/imeiiccidmismatch'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceMismatchListResult.from_hash(decoded)
    end

    # Move active devices from one billing account to another within a customer
    # profile.
    # @param [MoveDeviceRequest] body Required parameter: Request to move
    # devices between accounts.
    # @return [DeviceManagementResult] response from the API call
    def move_devices_within_accounts_of_profile(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/move'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Changes the provisioning state of one or more devices to a specified
    # customer-defined service and state.
    # @param [GoToStateRequest] body Required parameter: Request to change
    # device state to one defined by the user.
    # @return [DeviceManagementResult] response from the API call
    def update_devices_state(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/gotostate'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Changes the service plan for one or more devices.
    # @param [ServicePlanUpdateRequest] body Required parameter: Request to
    # change device service plan.
    # @return [DeviceManagementResult] response from the API call
    def change_devices_service_plan(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/plan'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Suspends service for one or more devices.
    # @param [CarrierActionsRequest] body Required parameter: Request to suspend
    # service for one or more devices.
    # @return [DeviceManagementResult] response from the API call
    def suspend_service_for_devices(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/suspend'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Restores service to one or more suspended devices.
    # @param [CarrierActionsRequest] body Required parameter: Request to restore
    # services of one or more suspended devices.
    # @return [DeviceManagementResult] response from the API call
    def restore_service_for_suspended_devices(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/actions/restore'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Checks whether specified devices are registered by the manufacturer with
    # the Verizon network and are available to be activated.
    # @param [DeviceActivationRequest] body Required parameter: Request to check
    # if devices can be activated or not.
    # @return [DeviceManagementResult] response from the API call
    def check_devices_availability_for_activation(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/availability/actions/list'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Each response includes a maximum of 500 records. To obtain more records,
    # you can call the API multiple times, adjusting the earliest value each
    # time to start where the previous request finished.
    # @param [DeviceConnectionListRequest] body Required parameter: Query to
    # retrieve device connection history.
    # @return [ConnectionHistoryResult] response from the API call
    def retrieve_device_connection_history(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/connections/actions/listHistory'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      ConnectionHistoryResult.from_hash(decoded)
    end

    # Changes or removes the CostCenterCode value or customer name and address
    # (Primary Place of Use) for one or more devices.
    # @param [DeviceCostCenterRequest] body Required parameter: Request to
    # update cost center code value for one or more devices.
    # @return [DeviceManagementResult] response from the API call
    def update_devices_cost_center_code(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/costCenter'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Returns extended diagnostic information about a specified device,
    # including connectivity, provisioning, billing and location status.
    # @param [DeviceExtendedDiagnosticsRequest] body Required parameter: Request
    # to query extended diagnostics information for a device.
    # @return [DeviceExtendedDiagnosticsResult] response from the API call
    def get_device_extended_diagnostic_information(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/extendeddiagnostics/actions/list'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceExtendedDiagnosticsResult.from_hash(decoded)
    end

    # Returns the provisioning history of a specified device during a specified
    # time period.
    # @param [DeviceProvisioningHistoryListRequest] body Required parameter:
    # Query to obtain device provisioning history.
    # @return [List of DeviceProvisioningHistoryListResult] response from the API call
    def list_devices_provisioning_history(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/history/actions/list'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      decoded.map { |element| DeviceProvisioningHistoryListResult.from_hash(element) }
    end

    # 4G and GSM devices do not have a PRL.
    # @param [DevicePrlListRequest] body Required parameter: Request to query
    # device PRL.
    # @return [DeviceManagementResult] response from the API call
    def list_current_devices_prl_version(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/prl/actions/list'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Returns DeviceSuspensionStatus callback messages containing the current
    # device state and information on how many days a device has been suspended
    # and can continue to be suspended.
    # @param [DeviceSuspensionStatusRequest] body Required parameter: Request to
    # obtain service suspenstion status for a device.
    # @return [DeviceManagementResult] response from the API call
    def get_device_service_suspension_status(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/suspension/status'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Returns the network data usage history of a device during a specified time
    # period.
    # @param [DeviceUsageListRequest] body Required parameter: Request to obtain
    # usage history for a specific device.
    # @return [DeviceUsageListResult] response from the API call
    def list_devices_usage_history(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/usage/actions/list'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceUsageListResult.from_hash(decoded)
    end

    # The information is returned in a callback response, so you must register a
    # URL for DeviceUsage callback messages using the POST /callbacks API.
    # @param [DeviceAggregateUsageListRequest] body Required parameter: A
    # request to retrieve aggregated device usage history information.
    # @return [DeviceManagementResult] response from the API call
    def retrieve_aggregate_device_usage_history(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/usage/actions/list/aggregate'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end

    # Changes the identifier of a 3G or 4G device to match hardware changes made
    # for a line of service. Use this request to transfer the line of service
    # and the MDN to new hardware, or to change the MDN.
    # @param [String] service_type Required parameter: Identifier type.
    # @param [ChangeDeviceIdRequest] body Required parameter: Request to update
    # device id.
    # @return [DeviceManagementResult] response from the API call
    def update_device_id(service_type,
                         body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/devices/{serviceType}/actions/deviceId'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'serviceType' => { 'value' => service_type, 'encode' => true }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise ConnectivityManagementResultException.new(
          'Error response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body)
      DeviceManagementResult.from_hash(decoded)
    end
  end
end
